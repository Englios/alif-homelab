apiVersion: apps/v1
kind: Deployment
metadata:
  name: tunnel-watchdog
  namespace: minecraft
spec:
  replicas: 1
  selector:
    matchLabels:
      app: tunnel-watchdog
  template:
    metadata:
      labels:
        app: tunnel-watchdog
    spec:
      serviceAccountName: tunnel-watchdog
      containers:
      - name: watchdog
        image: alpine:latest
        command: ["/bin/sh"]
        args:
          - -c
          - |
            # Install kubectl and additional tools
            apk add --no-cache curl jq netcat-openbsd
            
            # Install kubectl
            curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
            chmod +x kubectl
            mv kubectl /usr/local/bin/
            
            echo "üîç Starting Tunnel Watchdog..."
            echo "Monitoring $BORE_SERVER_TYPE server at $BORE_SERVER_IP"
            
            # Function to get current bore port
            get_bore_port() {
              case "$BORE_SERVER_TYPE" in
                "digitalocean")
                  # Get port from DigitalOcean tunnel logs
                  kubectl logs -n minecraft -l app=minecraft-bore-tunnel --tail=20 | \
                  grep "listening at $BORE_SERVER_IP:" | \
                  tail -1 | \
                  sed "s/.*listening at $BORE_SERVER_IP:\([0-9]*\).*/\1/"
                  ;;
                "homelab")
                  # Get port from homelab bore server logs
                  kubectl logs -n infrastructure -l app=bore-server --tail=10 | \
                  grep "new client host=0.0.0.0 port=" | \
                  tail -1 | \
                  sed 's/.*port=\([0-9]*\).*/\1/'
                  ;;
                *)
                  echo "Unknown bore server type: $BORE_SERVER_TYPE" >&2
                  return 1
                  ;;
              esac
            }
            
            # Function to test tunnel connectivity
            test_tunnel() {
              local port=$1
              if [ -z "$port" ]; then
                echo "‚ùå No port provided"
                return 1
              fi
              
              echo "üß™ Testing $BORE_SERVER_TYPE tunnel on $BORE_SERVER_IP:$port..."
              if timeout 10s nc -z "$BORE_SERVER_IP" "$port" 2>/dev/null; then
                echo "‚úÖ Tunnel accessible on $BORE_SERVER_IP:$port"
                return 0
              else
                echo "‚ùå Tunnel not accessible on $BORE_SERVER_IP:$port"
                return 1
              fi
            }
            
            # Function to restart bore tunnel
            restart_tunnel() {
              echo "üîÑ Restarting bore tunnel..."
              kubectl rollout restart deployment/minecraft-bore-tunnel -n minecraft
              
              # Wait for new pod to be ready
              echo "‚è≥ Waiting for new tunnel pod..."
              kubectl wait --for=condition=ready pod -l app=minecraft-bore-tunnel -n minecraft --timeout=120s
              
              # Wait a bit more for tunnel to establish
              sleep 30
            }
          
            # Main monitoring loop
            CONSECUTIVE_FAILURES=0
            MAX_FAILURES=3
            CHECK_INTERVAL=60
            
            while true; do
              echo "üîç Checking tunnel health..."
              
              # Get current port
              CURRENT_PORT=$(get_bore_port)
              
              if [ -z "$CURRENT_PORT" ]; then
                echo "‚ö†Ô∏è  No active tunnel port found"
                CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
              else
                # Test tunnel connectivity
                if test_tunnel "$CURRENT_PORT"; then
                  echo "‚úÖ Tunnel healthy on port $CURRENT_PORT"
                  CONSECUTIVE_FAILURES=0
                else
                  echo "‚ùå Tunnel unhealthy on port $CURRENT_PORT"
                  CONSECUTIVE_FAILURES=$((CONSECUTIVE_FAILURES + 1))
                fi
              fi
              
              # Check if we need to restart
              if [ $CONSECUTIVE_FAILURES -ge $MAX_FAILURES ]; then
                echo "üö® Tunnel has failed $CONSECUTIVE_FAILURES consecutive health checks. Restarting..."
                restart_tunnel
                CONSECUTIVE_FAILURES=0
                
                # Wait longer after restart
                sleep 120
              else
                sleep $CHECK_INTERVAL
              fi
            done
        resources:
          requests:
            memory: "32Mi"
            cpu: "50m"
          limits:
            memory: "64Mi"
            cpu: "100m"
        env:
        - name: BORE_SERVER_IP
          valueFrom:
            secretKeyRef:
              name: bore-server-config
              key: server-ip
        - name: BORE_SERVER_TYPE
          valueFrom:
            secretKeyRef:
              name: bore-server-config
              key: server-type

---
apiVersion: v1
kind: ServiceAccount
metadata:
  name: tunnel-watchdog
  namespace: minecraft

---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  namespace: minecraft
  name: tunnel-watchdog
rules:
- apiGroups: [""]
  resources: ["pods", "pods/log"]
  verbs: ["get", "list", "watch"]
- apiGroups: ["apps"]
  resources: ["deployments"]
  verbs: ["get", "list", "patch"]
- apiGroups: [""]
  resources: ["events"]
  verbs: ["create"]

---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: tunnel-watchdog
  namespace: minecraft
subjects:
- kind: ServiceAccount
  name: tunnel-watchdog
  namespace: minecraft
roleRef:
  kind: Role
  name: tunnel-watchdog
  apiGroup: rbac.authorization.k8s.io 